using Microsoft.Azure.KeyVault;
using Microsoft.Azure.Services.AppAuthentication;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.AzureKeyVault;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Azure.Storage.Queues; // Namespace for Queue storage types
using Azure.Storage.Queues.Models; // Namespace for PeekedMessage
using NUnit.Framework;
using Azure;
using System.Diagnostics;

namespace ExampleGov.BlobMalwareScan {
    class Program {
        const int oneSecond = 1000;
        const int maxFailuresBeforeExit = 10;
        static void Main() {
            int failures = 0;
            Console.WriteLine($"### Starting ExampleGov.BlobMalwareScan at {DateTime.Now}");
            while (failures < maxFailuresBeforeExit) {
                try {

                    MainTask().Wait();
                    failures = 0; //reset failure count
                    System.Threading.Thread.Sleep(5 * oneSecond); // Sleep for 5 seconds between run (Optional)
                }
                catch (Exception ex) {
                    Console.WriteLine($"Exception: Type = {ex.GetType()}, Message = {ex.Message}");

                    ex = ex.InnerException;
                    while (ex != null) {
                        Console.WriteLine($"Inner Exception: Type = {ex.GetType()}, Message = {ex.Message}");
                        ex = ex.InnerException;
                    }

                    failures += 1; // after exception then backoff
                    System.Threading.Thread.Sleep(failures * (oneSecond * 10)); 
                }
            }
            Console.WriteLine($"stopped after {failures} failures");
        }

        static async Task MainTask() {
            IConfiguration config = GetConfig();

            string quarantinePath = config.GetValue<string>("ExampleGov:BlobMalwareScanPath");
            string containerBlobMalwareQuarantine = config.GetValue<string>("ExampleGov:ContainerBlobMalwareQuarantine");
            string containerBlobMalwareScannedOK = config.GetValue<string>("ExampleGov:ContainerBlobMalwareScannedOK");
            string containerBlobMalwareFound = config.GetValue<string>("ExampleGov:ContainerBlobMalwareFound");
            string blobSASToken = config.GetValue<string>("BlobSASToken");
            string queueConnectionString = config.GetValue<string>("queueConnectionString");
            string workQueue = config.GetValue<string>("workQueue");

            //queue
            var queue = new QueueClient(queueConnectionString, workQueue);
            var blobStoreQuarantine = new BlobStorage(blobSASToken, containerBlobMalwareQuarantine);
            var blobStoreScannedOK = new BlobStorage(blobSASToken, containerBlobMalwareScannedOK);
            var blobStoreMalwareFound = new BlobStorage(blobSASToken, containerBlobMalwareFound);
            var fullFileName = "";

            Directory.CreateDirectory(quarantinePath);

            //See example: https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/storage/Azure.Storage.Queues/samples/Sample01b_HelloWorldAsync.cs#L32
            //TODO: decide how long it will take to process a file and set timespan to match to reduce liklihood of processsing twice if you have multiple consumers
            Response<QueueMessage[]> received = await queue.ReceiveMessagesAsync(10, TimeSpan.FromSeconds(10));

            // Download file
            foreach (QueueMessage message in received.Value) {
                // "Process" the message
                Console.WriteLine($"Message: {message.MessageText}");
                fullFileName = Path.Combine(quarantinePath, message.MessageText);

                using (Stream blobStream = await blobStoreQuarantine.DownloadDAAsync(message.MessageText))
                using (FileStream file = File.OpenWrite(fullFileName)) {
                    await blobStream.CopyToAsync(file);
                }
                Console.WriteLine($"<<finished download to '{fullFileName}'");

                //scan the file using Windows Defender
                var command = @"-Scan -ScanType 3 -DisableRemediation -File """ + fullFileName + "\"";
                var proc = new Process {
                    StartInfo = new ProcessStartInfo {
                        FileName = @"C:\Program Files\Windows Defender\MpCmdRun.exe",/// @"C:\\Windows\System32\cmd.exe",
                        Arguments = command,
                        RedirectStandardInput = false,
                        RedirectStandardError = false,
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        CreateNoWindow = true
                    }
                };
                proc.Start();

                while (!proc.HasExited) {
                    System.Threading.Thread.Sleep(oneSecond); // Sleep for 5 seconds between run
                }

                Console.WriteLine(proc.ExitCode);

                var exitcode = proc.ExitCode;
                if (exitcode == 0) {
                    //move blob to scannedok container
                    await blobStoreScannedOK.StartCopyAsyncToContainer(blobStoreQuarantine.GetBlockBlobReference(message.MessageText));
                    await blobStoreQuarantine.DeleteBlob(message.MessageText);
                }
                else {
                    Console.WriteLine($"<<virus found in '{fullFileName}'");
                    await blobStoreMalwareFound.StartCopyAsyncToContainer(blobStoreQuarantine.GetBlockBlobReference(message.MessageText));
                    await blobStoreQuarantine.DeleteBlob(message.MessageText);

                    while (!proc.StandardOutput.EndOfStream) {
                        string scanOutput = proc.StandardOutput.ReadLine();
                        // do something with line
                        Console.WriteLine(scanOutput);
                    }
                }

                //Delete message
                await queue.DeleteMessageAsync(message.MessageId, message.PopReceipt);
                Console.WriteLine($"<<deleted message '{fullFileName}'");
            }
        }

        private static IConfiguration GetConfig() {
            IConfiguration config = new ConfigurationBuilder()
                          .SetBasePath(Directory.GetCurrentDirectory())
                          .AddJsonFile("appsettings.json", false, true)
                          .Build();

            var azureServiceTokenProvider = new AzureServiceTokenProvider();

            var keyVaultClient = new KeyVaultClient(
                new KeyVaultClient.AuthenticationCallback(
                    azureServiceTokenProvider.KeyVaultTokenCallback));

            config = new ConfigurationBuilder()
                .AddConfiguration(config)
                .AddAzureKeyVault(
                     $"https://{config["KeyVaultName"]}.vault.azure.net/",
                    keyVaultClient,
                    new DefaultKeyVaultSecretManager())
                .Build();

            return config;
        }

        private class FileDetails {
            public string BlobUri { get; set; }

            public string md5 { get; set; }
        }
    }
}
